{
	"auto_complete":
	{
		"selected_items":
		[
		]
	},
	"buffers":
	[
		{
			"file": "src/NotifyIcon.hpp",
			"settings":
			{
				"buffer_size": 567,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "src/OS/FileInfo.hpp",
			"settings":
			{
				"buffer_size": 175,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"contents": "\n// dear imgui: standalone example application for DirectX 9\n// If you are new to dear imgui, see examples/README.txt and documentation at the top of imgui.cpp.\n#define START_WITH_VISU 1\n#define REGISTER_HOOKS 1\n#define REGISTER_MOUSE_HOOK 0\n#define REGISTER_EVENT_HOOK 1\n#define REGISTER_KEYBOARD_HOOK 0\n#define IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS   // [Win32] Don't implement default clipboard handler. Won't use and link with OpenClipboard/GetClipboardData/CloseClipboard etc.\n//#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS         // [Win32] Don't implement default IME handler. Won't use and link with ImmGetContext/ImmSetCompositionWindow.\n//#define IMGUI_DISABLE_WIN32_FUNCTIONS                     // [Win32] Won't use and link with any Win32 function.\n//#define IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS             // Don't implement ImFormatString/ImFormatStringV so you can implement them yourself if you don't want to link with vsnprintf.\n//#define IMGUI_DISABLE_MATH_FUNCTIONS                      // Don't implement ImFabs/ImSqrt/ImPow/ImFmod/ImCos/ImSin/ImAcos/ImAtan2 wrapper so you can implement them yourself. Declare your prototypes in imconfig.h.\n//#define IMGUI_DISABLE_DEFAULT_ALLOCATORS                  // Don't implement default allocators calling malloc()/free() to avoid linking with them. You will need to call ImGui::SetAllocatorFunctions().\n#include \"imgui.h\"\n#include <thread>\n#include \"imgui_impl_win32.h\"\n#include \"imgui_impl_opengl3.h\"\n#include \"GL/glew.h\"\n#include \"GL/wglew.h\"\n\n#include <tchar.h>\n\n#include <mutex>\n#include <atomic>\n#include <iostream>\n#include <iomanip>\n#include <filesystem>\n#include <set>\n#include <cassert>\n#include <unordered_set>\n\n#include \"resource.h\"\n\n#include \"render_stats.hpp\"\n#include \"keyboard.hpp\"\n#include \"Mouse.hpp\"\n#include \"Settings.hpp\"\n#include \"NotifyIcon.hpp\"\n#include \"Common.hpp\"\n#include \"TimeInfo.hpp\"\n#include \"file.hpp\"\n#include \"Logs.hpp\"\n#include \"Screen.hpp\"\n#include \"Event.hpp\"\n\n#include \"psapi.h\"\n\nconstexpr char* Mail_Name = \"\\\\\\\\.\\\\Mailslot\\\\Mes Touches\";\nconstexpr auto IDM_EXIT = 100;\nconstexpr auto WM_NOTIFY_MSG = WM_APP + 1;\nconstexpr auto Quit_Request = WM_APP + 2;\nUINT Mail_Arrived_Msg = WM_NULL;\n// Data\nstatic LPDIRECT3DDEVICE9\t\tg_pd3dDevice = NULL;\nstatic D3DPRESENT_PARAMETERS\tg_d3dpp;\n\nvoid window_process() noexcept;\n\nextern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);\n\nvoid event_queue_process() noexcept;\n\nLRESULT CALLBACK display_hook();\nLRESULT CALLBACK keyboard_hook(int n_code, WPARAM w_param, LPARAM l_param) noexcept;\nLRESULT CALLBACK mouse_hook(int n_code, WPARAM w_param, LPARAM l_param) noexcept;\nLRESULT CALLBACK event_hook(int n_code, WPARAM w_param, LPARAM l_param) noexcept;\n\nstd::optional<std::string> get_last_error_message() noexcept;\nstd::optional<HGLRC> create_gl_context(HWND handle_window) noexcept;\nvoid destroy_gl_context(HGLRC gl_context) noexcept;\n\nstruct Mail_Message {\n\tint n_code;\n\tWPARAM w_param;\n\tLPARAM l_param;\n};\nvoid make_mail() noexcept;\nstd::optional<Mail_Message> read_mail() noexcept;\n\n// It's shared data between the hook process and the windows process.\nstruct SharedData {\n\tstd::mutex mut_keyboard_state;\n\tstd::optional<KeyboardState> keyboard_state;\n\n\tstd::mutex mut_mouse_state;\n\tstd::optional<MouseState> mouse_state;\n\n\tstd::mutex mut_event_state;\n\tstd::optional<EventState> event_state;\n\n\tstd::atomic<HWND> hook_window = nullptr;\n\tstd::atomic<HWND> visu_window = nullptr;\n\tSettings settings;\n\n\tHANDLE mail_slot = INVALID_HANDLE_VALUE;\n} shared;\n\nconstexpr auto hook_class_name = \"Hook MT\";\nconstexpr auto visu_class_name = \"Visu MT\";\nconstexpr auto window_title = \"Mes Touches\";\n\nLogs logs;\n\nstruct EventQueueCache {\n\tstd::mutex mutex;\n\tstd::condition_variable wait_var;\n\tbool event_received{ false };\n\n\tstd::vector<KeyEntry> keyboard;\n\tstd::vector<ClickEntry> click;\n\tstd::vector<Display> display;\n\tstd::vector<AppUsage> app_usages;\n} event_queue_cache;\n\nvoid toggle_fullscren(HWND hwnd) {\n\tstatic WINDOWPLACEMENT g_wpPrev = { sizeof(g_wpPrev) };\n\n\tDWORD dwStyle = GetWindowLong(hwnd, GWL_STYLE);\n\tif (dwStyle & WS_OVERLAPPEDWINDOW) {\n\t\tMONITORINFO mi = { sizeof(mi) };\n\t\tif (\n\t\t\tGetWindowPlacement(hwnd, &g_wpPrev) &&\n\t\t\tGetMonitorInfo(MonitorFromWindow(hwnd, MONITOR_DEFAULTTOPRIMARY), &mi)\n\t\t\t) {\n\t\t\tSetWindowLong(hwnd, GWL_STYLE, dwStyle & ~WS_OVERLAPPEDWINDOW);\n\t\t\tSetWindowPos(\n\t\t\t\thwnd, HWND_TOP,\n\t\t\t\tmi.rcMonitor.left, mi.rcMonitor.top,\n\t\t\t\tmi.rcMonitor.right - mi.rcMonitor.left,\n\t\t\t\tmi.rcMonitor.bottom - mi.rcMonitor.top,\n\t\t\t\tSWP_NOOWNERZORDER | SWP_FRAMECHANGED\n\t\t\t);\n\t\t}\n\t}\n\telse {\n\t\tSetWindowLong(hwnd, GWL_STYLE, dwStyle | WS_OVERLAPPEDWINDOW);\n\t\tSetWindowPlacement(hwnd, &g_wpPrev);\n\t\tSetWindowPos(\n\t\t\thwnd,\n\t\t\tNULL,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\tSWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_FRAMECHANGED\n\t\t);\n\t}\n}\n\nLRESULT WINAPI WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) noexcept {\n\tif (msg == Mail_Arrived_Msg) if (auto res = read_mail(); res) {\n\t\tevent_hook(res->n_code, res->w_param, res->l_param);\n\t}\n\n\tswitch (msg)\n\t{\n\tcase WM_NOTIFY_MSG: {\n\t\tswitch (lParam) {\n\t\tcase WM_LBUTTONDBLCLK:\n\t\t\tif (!shared.visu_window) {\n\t\t\t\tstd::thread{ window_process }.detach();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSetForegroundWindow(shared.visu_window);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WM_RBUTTONDOWN:\n\t\tcase WM_CONTEXTMENU:\n\t\t\tPOINT pt;\n\t\t\tGetCursorPos(&pt);\n\t\t\tauto menu = CreatePopupMenu();\n\t\t\tInsertMenu(\n\t\t\t\tmenu, 0, MF_BYPOSITION | MF_STRING, IDM_EXIT, TEXT(\"Quit\")\n\t\t\t);\n\t\t\tSetForegroundWindow(hWnd);\n\t\t\tTrackPopupMenu(\n\t\t\t\tmenu,\n\t\t\t\tGetSystemMetrics(SM_MENUDROPALIGNMENT) | TPM_LEFTBUTTON,\n\t\t\t\tpt.x,\n\t\t\t\tpt.y,\n\t\t\t\t0,\n\t\t\t\thWnd,\n\t\t\t\tNULL\n\t\t\t);\n\t\t\tDestroyMenu(menu);\n\t\t\tbreak;\n\t\t}\n\t} break;\n\tcase WM_SYSCOMMAND:\n\t\tif ((wParam & 0xfff0) == SC_KEYMENU) // Disable ALT application menu\n\t\t\treturn 0;\n\t\tbreak;\n\tcase WM_DESTROY:\n\tcase Quit_Request:\n\t\tPostQuitMessage(0);\n\t\treturn 0;\n\tcase WM_COMMAND:\n\t\tswitch (LOWORD(wParam)) {\n\t\t\tcase IDM_EXIT:\n\t\t\t\tPostQuitMessage(0);\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn DefWindowProc(hWnd, msg, wParam, lParam);\n}\n\nstatic bool visu_windows_ended = false;\nLRESULT WINAPI WndProc_visu(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) noexcept {\n\tif (ImGui_ImplWin32_WndProcHandler(hWnd, msg, wParam, lParam))\n\t\treturn true;\n\n\tswitch (msg)\n\t{\n\tcase WM_KEYDOWN: {\n\t\tif (wParam == VK_F11) toggle_fullscren(hWnd);\n\t\tbreak;\n\t}\n\tcase WM_SIZE:\n\t\treturn 0;\n\tcase WM_SYSCOMMAND:\n\t\tif ((wParam & 0xfff0) == SC_KEYMENU) // Disable ALT application menu\n\t\t\treturn 0;\n\t\tbreak;\n\tcase Quit_Request:\n\t\tif (shared.hook_window) {\n\t\t\tPostMessage(shared.hook_window, Quit_Request, NULL, NULL);\n\t\t}\n\tcase WM_DESTROY:\n\t\tvisu_windows_ended = true;\n\t\tPostQuitMessage(0);\n\t\treturn 0;\n\t}\n\treturn DefWindowProc(hWnd, msg, wParam, lParam);\n}\n\n#ifdef DEBUG_CONSOLE\nint main() {\n#else\nint __stdcall WinMain(HINSTANCE, HINSTANCE, LPSTR, int) {\n#endif\n\tauto time_start = get_milliseconds_epoch();\n\n\tstd::filesystem::create_directories(get_app_data_path());\n\t\n\tshared.settings.copy_system();\n\tshared.keyboard_state =\n\t\tKeyboardState::load_from_file(get_app_data_path() / Default_Keyboard_Path);\n\tshared.mouse_state =\n\t\tMouseState::load_from_file(get_app_data_path() / MouseState::Default_Path, true);\n\tshared.event_state =\n\t\tEventState::load_from_file(get_app_data_path() / EventState::Default_Path);\n\n\tdefer{\n\t\tif (shared.keyboard_state) {\n\t\t\t(void)shared.keyboard_state->save_to_file(get_app_data_path() / Default_Keyboard_Path);\n\t\t}\n\n\t\tif (shared.mouse_state){\n\t\t\t(void)shared.mouse_state->save_to_file(get_app_data_path() / MouseState::Default_Path);\n\t\t}\n\n\t\tif (shared.event_state){\n\t\t\t(void)shared.event_state->save_to_file(get_app_data_path() / EventState::Default_Path);\n\t\t}\n\t};\n\n\t// Create application window\n\tWNDCLASSEX wc = {\n\t\tsizeof(WNDCLASSEX),\n\t\tCS_CLASSDC,\n\t\tWndProc,\n\t\t0L,\n\t\t0L,\n\t\tGetModuleHandle(nullptr),\n\t\tnullptr,\n\t\tnullptr,\n\t\tnullptr,\n\t\tnullptr,\n\t\thook_class_name,\n\t\tnullptr\n\t};\n\n\twc.hIcon = LoadIcon(wc.hInstance, MAKEINTRESOURCE(IDI_ICON1));\n\twc.hIconSm = wc.hIcon;\n\n\tRegisterClassEx(&wc);\n\tdefer{ UnregisterClass(hook_class_name, wc.hInstance); };\n\tHWND hwnd = CreateWindow(\n\t\thook_class_name,\n\t\twindow_title,\n\t\tWS_OVERLAPPED,\n\t\t400,\n\t\t300,\n\t\t0,\n\t\t0,\n\t\tNULL,\n\t\tNULL,\n\t\twc.hInstance,\n\t\tNULL\n\t);\n\tshared.hook_window = hwnd;\n\n\t// so now we are after the creation of the koow window\n\t// but before its registration as a hook so it's the perfect time\n\t// to start the event_queue process.\n\tstd::thread{ event_queue_process }.detach();\n\n\tdefer{ DestroyWindow(hwnd); };\n\tdefer{ shared.hook_window = nullptr; };\n\n#if REGISTER_HOOKS\n#if REGISTER_KEYBOARD_HOOK\n\tSetWindowsHookEx(WH_KEYBOARD_LL, keyboard_hook, NULL, NULL);\n#endif\n#if REGISTER_MOUSE_HOOK\n\tSetWindowsHookEx(WH_MOUSE_LL, mouse_hook, NULL, NULL);\n#endif\n#if REGISTER_EVENT_HOOK\n\t__declspec(dllimport) bool install_hook();\n\t__declspec(dllimport) bool uninstall_hook();\n\n\tMail_Arrived_Msg = RegisterWindowMessage(Mail_Name);\n\tmake_mail();\n\tinstall_hook();\n\tdefer { uninstall_hook(); };\n#endif\n#endif\n\n\tNotifyIcon sys_tray_icon;\n\tsys_tray_icon.set_icon(wc.hIcon);\n\tsys_tray_icon.set_tooltip(\"You can open me\");\n\tsys_tray_icon.set_window(hwnd);\n\tsys_tray_icon.set_message(WM_NOTIFY_MSG);\n\tsys_tray_icon.add();\n\tsys_tray_icon.show();\n\tdefer{ sys_tray_icon.remove(); };\n\n\tLogEntry entry;\n\tentry.message = \"Started in: \" + std::to_string(get_milliseconds_epoch() - time_start) + \"ms.\";\n\tentry.tag.push_back(\"PERF\");\n\tlogs.lock_and_write(entry);\n\n#if START_WITH_VISU\n\tstd::thread{ window_process }.detach();\n#endif\n\n\tMSG msg{};\n\twhile (GetMessage(&msg, NULL, 0U, 0U)) {\n\t\tTranslateMessage(&msg);\n\t\tDispatchMessage(&msg);\n\t}\n\n\treturn 0;\n}\n\nvoid window_process() noexcept {\n\tLogWindow log_window;\n\tMouseWindow mou_window;\n\tSettingsWindow set_window;\n\tKeyboardWindow key_window;\n\tEventWindow eve_window;\n\tvisu_windows_ended = false;\n\t// Create application window\n\tWNDCLASSEX wc = {\n\t\tsizeof(WNDCLASSEX),\n\t\tCS_CLASSDC,\n\t\tWndProc_visu,\n\t\t0L,\n\t\t0L,\n\t\tGetModuleHandle(NULL),\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\t\tvisu_class_name,\n\t\tNULL\n\t};\n\twc.hIcon = LoadIcon(wc.hInstance, MAKEINTRESOURCE(IDI_ICON1));\n\twc.hIconSm = wc.hIcon;\n\n\tRegisterClassEx(&wc);\n\tHWND hwnd = CreateWindow(\n\t\tvisu_class_name,\n\t\twindow_title,\n\t\tWS_OVERLAPPEDWINDOW,\n\t\t100,\n\t\t75,\n\t\t1280,\n\t\t720,\n\t\tNULL,\n\t\tNULL,\n\t\twc.hInstance,\n\t\tNULL\n\t);\n\tshared.visu_window = hwnd;\n\n\tdefer{\n\t\tUnregisterClass(visu_class_name, wc.hInstance);\n\t\tDestroyWindow(hwnd);\n\t\tshared.visu_window = nullptr;\n\t};\n\n\n\tauto gl_context = *create_gl_context(hwnd);\n\tdefer{ destroy_gl_context(gl_context); };\n\n\t// Setup Dear ImGui context\n\tIMGUI_CHECKVERSION();\n\tImGui::CreateContext();\n\tImGuiIO& io = ImGui::GetIO(); (void)io;\n\tio.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;       // Enable Keyboard Controls\n\t//io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls\n\tio.ConfigFlags |= ImGuiConfigFlags_DockingEnable;           // Enable Docking\n\tio.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable;         // Enable Multi-Viewport / Platform Windows\n\t//io.ConfigViewportsNoAutoMerge = true;\n\t//io.ConfigViewportsNoTaskBarIcon = true;\n\n\t// Setup Dear ImGui style\n\tImGui::StyleColorsDark();\n\t//ImGui::StyleColorsClassic();\n\n\t// When viewports are enabled we tweak WindowRounding/WindowBg so platform windows can look identical to regular ones.\n\tImGuiStyle& style = ImGui::GetStyle();\n\tif (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)\n\t{\n\t\tstyle.WindowRounding = 0.0f;\n\t\tstyle.Colors[ImGuiCol_WindowBg].w = 1.0f;\n\t}\n\n\t// Setup Platform/Renderer bindings\n\tImGui_ImplWin32_Init(hwnd);\n\tImGui_ImplOpenGL3_Init();\n\n\tauto dc_window = GetDC(hwnd);\n\tif (!dc_window) {\n\t\t// >TODO error handling\n\t\tprintf(\"%s\", get_last_error_message()->c_str());\n\t\treturn;\n\t}\n\t\n\tdefer{\n\t\tImGui_ImplOpenGL3_Shutdown();\n\t\tImGui_ImplWin32_Shutdown();\n\t\tImGui::DestroyContext();\n\t};\n\n\t// Main loop\n\tMSG msg = {};\n\tShowWindow(hwnd, SW_SHOWDEFAULT);\n\tUpdateWindow(hwnd);\n\n\tauto delta_clock = get_microseconds_epoch();\n\twhile (msg.message != WM_QUIT) {\n\t\tauto dt = (get_microseconds_epoch() - delta_clock) / 1'000'000.0;\n\t\tdelta_clock = get_microseconds_epoch();\n\n\t\tif (PeekMessage(&msg, NULL, 0U, 0U, PM_REMOVE)) {\n\t\t\tTranslateMessage(&msg);\n\t\t\tDispatchMessage(&msg);\n\t\t}\n\t\tif (visu_windows_ended) break;\n\t\t// Start the Dear ImGui frame\n\t\tImGui_ImplOpenGL3_NewFrame();\n\t\tImGui_ImplWin32_NewFrame();\n\t\tImGui::NewFrame();\n\n\t\tglClearColor(0.5f, 0.5f, 0.5f, 1.f);\n\t\tglClear(GL_COLOR_BUFFER_BIT);\n\n\t\tstatic ImGuiDockNodeFlags dockspace_flags = ImGuiDockNodeFlags_None;\n\n\t\t// We are using the ImGuiWindowFlags_NoDocking flag to make the parent window not dockable into,\n\t\t// because it would be confusing to have two docking targets within each others.\n\t\tImGuiWindowFlags window_flags = ImGuiWindowFlags_NoDocking;\n\t\tImGuiViewport* viewport = ImGui::GetMainViewport();\n\t\tImGui::SetNextWindowPos(viewport->GetWorkPos());\n\t\tImGui::SetNextWindowSize(viewport->GetWorkSize());\n\t\tImGui::SetNextWindowViewport(viewport->ID);\n\t\tImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);\n\t\tImGui::PushStyleVar(ImGuiStyleVar_WindowBorderSize, 0.0f);\n\t\twindow_flags |= ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove;\n\t\twindow_flags |= ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_NoNavFocus;\n\n\t\t// When using ImGuiDockNodeFlags_PassthruCentralNode, DockSpace() will render our background\n\t\t// and handle the pass-thru hole, so we ask Begin() to not render a background.\n\t\tif (dockspace_flags & ImGuiDockNodeFlags_PassthruCentralNode)\n\t\t\twindow_flags |= ImGuiWindowFlags_NoBackground;\n\n\t\t// Important: note that we proceed even if Begin() returns false (aka window is collapsed).\n\t\t// This is because we want to keep our DockSpace() active. If a DockSpace() is inactive,\n\t\t// all active windows docked into it will lose their parent and become undocked.\n\t\t// We cannot preserve the docking relationship between an active window and an inactive docking, otherwise\n\t\t// any change of dockspace/settings would lead to windows being stuck in limbo and never being visible.\n\t\tImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.0f, 0.0f));\n\t\tImGui::Begin(\"DockSpace Demo\", nullptr, window_flags);\n\t\tImGui::PopStyleVar();\n\t\tImGui::PopStyleVar(2);\n\t\t\n\t\tImGui::DockSpace(ImGui::GetID(\"dock\"));\n\n\t\tImGui::Begin(\"Debug\");\n\t\tImGui::Text(\"%f\", 1.f / (float)dt);\n\t\tImGui::End();\n\n\t\tkey_window.render(shared.keyboard_state);\n\t\tmou_window.render(shared.mouse_state);\n\t\teve_window.render(shared.event_state);\n\t\tset_window.render(shared.settings);\n\t\tlog_window.render(logs);\n\n\t\tif (ImGui::BeginPopup(\"Error Prompt\")) {\n\t\t\tdefer{ ImGui::EndPopup(); };\n\n\t\t\tImGui::Text(\"The last action ended with an error see the logs for more details.\");\n\t\t}\n\n\t\t// update\n\t\tif (set_window.show_log) {\n\t\t\tlog_window.open = true;\n\t\t\tset_window.show_log = false;\n\t\t}\n\t\tif (set_window.reset_keyboard_state && shared.keyboard_state) {\n\t\t\tstd::lock_guard guard{ shared.mut_keyboard_state };\n\t\t\tif (!shared.keyboard_state->reset_everything()) {\n\t\t\t\tImGui::OpenPopup(\"Error Prompt\");\n\t\t\t}\n\t\t\tset_window.reset_keyboard_state = false;\n\t\t}\n\t\tif (set_window.reset_mouse_state && shared.mouse_state) {\n\t\t\tstd::lock_guard guard{ shared.mut_mouse_state };\n\t\t\tif (!shared.mouse_state->reset_everything()) {\n\t\t\t\tImGui::OpenPopup(\"Error Prompt\");\n\t\t\t}\n\t\t\tset_window.reset_mouse_state = false;\n\t\t}\n\t\tif (set_window.quit) {\n\t\t\tPostMessage(shared.visu_window, Quit_Request, 0, 0);\n\t\t\t// set_window.quit = false. We don't reset it because a quit is authoritative.\n\t\t\t// we will spam messages until we quit.\n\t\t}\n\t\tif (set_window.install) {\n\n\t\t}\n\n\t\tif (key_window.reset) {\n\t\t\tauto t = std::lock_guard{ shared.mut_keyboard_state };\n\t\t\tif (!shared.keyboard_state) shared.keyboard_state = KeyboardState{};\n\t\t\tif (!shared.keyboard_state->reset_everything()) {\n\t\t\t\tImGui::OpenPopup(\"Error Prompt\");\n\t\t\t}\n\t\t\tkey_window.reset = false;\n\t\t}\n\t\tif (key_window.save) {\n\t\t\tauto full_path = get_app_data_path() / Default_Keyboard_Path;\n\t\t\tauto t = std::lock_guard{ shared.mut_keyboard_state };\n\t\t\tif (!shared.keyboard_state->save_to_file(full_path)) {\n\t\t\t\tImGui::OpenPopup(\"Error Prompt\");\n\t\t\t}\n\t\t\tkey_window.save = false;\n\t\t}\n\t\tif (key_window.reload) {\n\t\t\tauto full_path = get_app_data_path() / Default_Keyboard_Path;\n\t\t\tauto t = std::lock_guard{ shared.mut_keyboard_state };\n\t\t\tauto opt = KeyboardState::load_from_file(full_path);\n\t\t\tif (opt) shared.keyboard_state = *opt;\n\t\t\telse ImGui::OpenPopup(\"Error Prompt\");\n\t\t\tkey_window.reload = false;\n\t\t}\n\n\t\tif (mou_window.reset) {\n\t\t\tauto t = std::lock_guard{ shared.mut_mouse_state };\n\t\t\tif (!shared.mouse_state) shared.mouse_state = MouseState{};\n\t\t\tif (!shared.mouse_state->reset_everything()) {\n\t\t\t\tImGui::OpenPopup(\"Error Prompt\");\n\t\t\t}\n\t\t\tmou_window.reset = false;\n\t\t}\n\t\tif (mou_window.save) {\n\t\t\tauto full_path = get_app_data_path() / MouseState::Default_Path;\n\t\t\tauto t = std::lock_guard{ shared.mut_mouse_state };\n\t\t\tif (!shared.mouse_state->save_to_file(full_path)) {\n\t\t\t\tImGui::OpenPopup(\"Error Prompt\");\n\t\t\t}\n\t\t\tmou_window.save = false;\n\t\t}\n\t\tif (mou_window.reload) {\n\t\t\tauto full_path = get_app_data_path() / MouseState::Default_Path;\n\t\t\tauto t = std::lock_guard{ shared.mut_mouse_state };\n\t\t\tauto opt = MouseState::load_from_file(full_path, mou_window.strict);\n\t\t\tif (opt) shared.mouse_state = *opt;\n\t\t\telse ImGui::OpenPopup(\"Error Prompt\");\n\t\t\tmou_window.reload = false;\n\t\t}\n\n\n\t\tif (eve_window.reset) {\n\t\t\tauto t = std::lock_guard{ shared.mut_event_state };\n\t\t\tif (!shared.event_state) shared.event_state = EventState{};\n\t\t\tif (!shared.event_state->reset_everything()) {\n\t\t\t\tImGui::OpenPopup(\"Error Prompt\");\n\t\t\t}\n\t\t\teve_window.reset = false;\n\t\t}\n\t\tif (eve_window.save) {\n\t\t\tauto full_path = get_app_data_path() / EventState::Default_Path;\n\t\t\tauto t = std::lock_guard{ shared.mut_event_state };\n\t\t\tif (!shared.event_state->save_to_file(full_path)) {\n\t\t\t\tImGui::OpenPopup(\"Error Prompt\");\n\t\t\t}\n\t\t\teve_window.save = false;\n\t\t}\n\t\tif (eve_window.reload) {\n\t\t\tauto full_path = get_app_data_path() / EventState::Default_Path;\n\t\t\tauto t = std::lock_guard{ shared.mut_event_state };\n\t\t\tauto opt = EventState::load_from_file(full_path);\n\t\t\tif (opt) shared.event_state = *opt;\n\t\t\telse ImGui::OpenPopup(\"Error Prompt\");\n\t\t\teve_window.reload = false;\n\t\t}\n\n\t\tImGui::End();\n\t\t// Rendering\n\t\tImGui::Render();\n\t\tImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());\n\t\tSwapBuffers(dc_window);\n\t\t//using namespace std::chrono_literals;\n\t\t//std::this_thread::sleep_for(16ms);\n\t}\n}\n\nLRESULT CALLBACK keyboard_hook(int n_code, WPARAM w_param, LPARAM l_param) noexcept {\n\tthread_local std::vector<KeyEntry> key_entries_to_add;\n\n\tauto time_start = get_microseconds_epoch();\n\tdefer{\n\t\tauto time_end = get_microseconds_epoch();\n\t\tauto dt = time_end - time_start;\n\n\t\tif (dt > 500) {\n\t\t\tLogEntry entry;\n\t\t\tentry.message = \"Keyboard hook blocked for: \" + std::to_string(dt) + \"us.\";\n\t\t\tentry.tag.push_back(\"PERF\");\n\t\t\tlogs.lock_and_write(entry);\n\t\t}\n\t};\n\n\n\tif (n_code < 0) return CallNextHookEx(NULL, n_code, w_param, l_param);\n\n\tswitch (w_param) {\n\tcase WM_KEYUP:\n\tcase WM_SYSKEYUP: {\n\t\tauto& arg = *(KBDLLHOOKSTRUCT*)l_param;\n\t\tKeyEntry entry;\n\t\tentry.key_code = (uint8_t)arg.vkCode;\n\t\tentry.timestamp = get_seconds_epoch();\n\n\t\tkey_entries_to_add.push_back(entry);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!key_entries_to_add.empty() && event_queue_cache.mutex.try_lock()) {\n\t\tdefer{\n\t\t\tevent_queue_cache.mutex.unlock();\n\t\t\tevent_queue_cache.wait_var.notify_all();\n\t\t};\n\n\t\tfor (auto& x : key_entries_to_add) event_queue_cache.keyboard.push_back(x);\n\t\tkey_entries_to_add.resize(0);\n\t}\n\n\treturn CallNextHookEx(NULL, n_code, w_param, l_param);\n}\n\nLRESULT CALLBACK mouse_hook(int n_code, WPARAM w_param, LPARAM l_param) noexcept {\n\tthread_local std::vector<ClickEntry> click_entries_to_add;\n\n\tauto time_start = get_microseconds_epoch();\n\tdefer{\n\t\tauto time_end = get_microseconds_epoch();\n\t\tauto dt = time_end - time_start;\n\n\t\tif (dt > 500) {\n\t\t\tLogEntry entry;\n\t\t\tentry.message = \"Mouse hook blocked for: \" + std::to_string(dt) + \"us.\";\n\t\t\tentry.tag.push_back(\"PERF\");\n\t\t\tlogs.lock_and_write(entry);\n\t\t}\n\t};\n\n\tif (n_code < 0) return CallNextHookEx(NULL, n_code, w_param, l_param);\n\n\n\tswitch (w_param) {\n\tcase WM_LBUTTONUP:\n\tcase WM_RBUTTONUP:\n\tcase WM_MBUTTONUP:\n\tcase WM_XBUTTONUP:\n\tcase WM_MOUSEWHEEL: {\n\t\tauto& arg = *(MSLLHOOKSTRUCT*)l_param;\n\t\tClickEntry click;\n\t\tclick.timestamp = get_seconds_epoch();\n\t\tswitch (w_param) {\n\t\tcase WM_LBUTTONUP:\n\t\t\tclick.button_code = (uint8_t)MouseState::ButtonMap::Left;\n\t\t\tbreak;\n\t\tcase WM_RBUTTONUP:\n\t\t\tclick.button_code = (uint8_t)MouseState::ButtonMap::Right;\n\t\t\tbreak;\n\t\tcase WM_MOUSEWHEEL:\n\t\t\tif ((short)(arg.mouseData >> (8 * sizeof(WORD))) > 0) {\n\t\t\t\tclick.button_code = (uint8_t)MouseState::ButtonMap::Wheel_Up;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tclick.button_code = (uint8_t)MouseState::ButtonMap::Wheel_Down;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WM_MBUTTONUP:\n\t\t\tclick.button_code = (uint8_t)MouseState::ButtonMap::Wheel;\n\t\t\tbreak;\n\t\tcase WM_XBUTTONUP:\n\t\t\tif ((arg.mouseData >> (8 * sizeof(WORD))) == XBUTTON1) {\n\t\t\t\tclick.button_code = (uint8_t)MouseState::ButtonMap::Mouse_3;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tclick.button_code = (uint8_t)MouseState::ButtonMap::Mouse_4;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tclick.x = arg.pt.x;\n\t\tclick.y = arg.pt.y;\n\t\tclick_entries_to_add.push_back(click);\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!click_entries_to_add.empty() && event_queue_cache.mutex.try_lock()) {\n\t\tdefer{\n\t\t\tevent_queue_cache.mutex.unlock();\n\t\t\tevent_queue_cache.wait_var.notify_all();\n\t\t};\n\n\t\tfor (auto& x : click_entries_to_add) event_queue_cache.click.push_back(x);\n\n\t\tclick_entries_to_add.resize(0);\n\t}\n\n\treturn CallNextHookEx(NULL, n_code, w_param, l_param);\n}\n\nLRESULT CALLBACK event_hook(int n_code, WPARAM w_param, LPARAM l_param) noexcept {\n\tthread_local std::unordered_map<HWND, std::uint64_t> opened;\n\tthread_local std::vector<AppUsage> entries_to_add;\n\n\tchar big_buffer[1024];\n\tGetModuleFileNameA(NULL, big_buffer, sizeof(big_buffer));\n\n\tswitch(n_code) {\n\t\tcase HCBT_CREATEWND:{\n\t\t\tWCHAR wide_buffer[MAX_PATH] = {};\n\t\t\tDWORD proc_id = 0;\n\t\t\tGetWindowThreadProcessId((HWND)w_param, &proc_id);\n\t\t\tauto handle_process =\n\t\t\t\tOpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, proc_id);\n\n\t\t\tGetModuleFileNameExW(handle_process, NULL, wide_buffer, MAX_PATH);\n\t\t\tOutputDebugStringW(L\"Opened: \");\n\t\t\tOutputDebugStringW(wide_buffer);\n\t\t\tOutputDebugStringW(L\"\\n\");\n\t\t\topened[(HWND)w_param] = get_microseconds_epoch();\n\t\t\tbreak;\n\t\t}\n\t\tcase HCBT_DESTROYWND: {\n\t\t\tif (opened.count((HWND)w_param) == 0) break;\n\n\t\t\tAppUsage use;\n\t\t\tuse.timestamp_start = opened[(HWND)\n\t\t\tw_param];\n\t\t\tuse.timestamp_end = get_microseconds_epoch();\n\n\t\t\tWCHAR wide_buffer[MAX_PATH] = {};\n\t\t\tGetWindowTextW((HWND)w_param, wide_buffer, MAX_PATH);\n\n\t\t\tauto size = WideCharToMultiByte(\n\t\t\t\tCP_UTF8, 0, wide_buffer, -1, nullptr, 0, NULL, NULL\n\t\t\t);\n\t\t\tif (size == 1) break; // If after that we don't know the name then there is no point to continue.\n\n\t\t\tuse.doc_name = {};\n\t\t\tWideCharToMultiByte(\n\t\t\t\tCP_UTF8,\n\t\t\t\t0,\n\t\t\t\twide_buffer,\n\t\t\t\t-1,\n\t\t\t\tuse.doc_name.data(),\n\t\t\t\tuse.doc_name.size(),\n\t\t\t\tNULL,\n\t\t\t\tNULL\n\t\t\t);\n\n\t\t\tOutputDebugStringW(L\"Doc: \");\n\t\t\tOutputDebugStringW(wide_buffer);\n\t\t\tOutputDebugStringW(L\"\\n\");\n\n\t\t\tDWORD proc_id = 0;\n\t\t\tGetWindowThreadProcessId((HWND)w_param, &proc_id);\n\t\t\tauto handle_process =\n\t\t\t\tOpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, proc_id);\n\n\t\t\tGetModuleFileNameExW(handle_process, NULL, wide_buffer, MAX_PATH);\n\t\t\tsize = WideCharToMultiByte(\n\t\t\t\tCP_UTF8, 0, wide_buffer, -1, nullptr, 0, NULL, NULL\n\t\t\t);\n\t\t\tif (size > 1) {\n\t\t\t\tOutputDebugStringW(L\"Exe: \");\n\t\t\t\tOutputDebugStringW(wide_buffer);\n\t\t\t\tOutputDebugStringW(L\"\\n\");\n\t\t\t\tWideCharToMultiByte(\n\t\t\t\t\tCP_UTF8,\n\t\t\t\t\t0,\n\t\t\t\t\twide_buffer,\n\t\t\t\t\t-1,\n\t\t\t\t\tuse.exe_name.data(),\n\t\t\t\t\tuse.exe_name.size(),\n\t\t\t\t\tNULL,\n\t\t\t\t\tNULL\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tauto default_string = \"Internal\";\n\t\t\t\tfor (size_t i = 0; i < strlen(default_string); ++i) {\n\t\t\t\t\tuse.exe_name[i] = default_string[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentries_to_add.push_back(use);\n\t\t\topened.erase((HWND)w_param);\n\t\t\tbreak;\n\t\t}\n\t};\n\n\tif (!entries_to_add.empty() && event_queue_cache.mutex.try_lock()) {\n\t\tdefer {\n\t\t\tentries_to_add.clear();\n\t\t\tevent_queue_cache.mutex.unlock();\n\t\t\tevent_queue_cache.wait_var.notify_all();\n\t\t};\n\n\t\tfor (auto& x : entries_to_add)\n\t\t\tevent_queue_cache.app_usages.push_back(x);\n\t}\n\n\treturn CallNextHookEx(NULL, n_code, w_param, l_param);\n}\n\nClickEntry transform_click_to_canonical(ClickEntry x) noexcept;\nvoid update_displays_from_click(MouseState& state, ClickEntry x) noexcept;\n\nvoid event_queue_process() noexcept {\n\twhile (shared.hook_window != nullptr) {\n\t\tstd::unique_lock lk{ event_queue_cache.mutex };\n\t\tevent_queue_cache.wait_var.wait(lk, [] {\n\t\t\treturn\n\t\t\t\t!event_queue_cache.click.empty() ||\n\t\t\t\t!event_queue_cache.display.empty() ||\n\t\t\t\t!event_queue_cache.keyboard.empty() ||\n\t\t\t\t!event_queue_cache.app_usages.empty();\n\t\t});\n\t\tevent_queue_cache.event_received = false;\n\n\t\tif (\n\t\t\tshared.mouse_state &&\n\t\t\t(!event_queue_cache.click.empty() || !event_queue_cache.display.empty())&&\n\t\t\t// Maybe we should be more aggresive and do a lock here instead ?\n\t\t\tshared.mut_mouse_state.try_lock()\n\t\t) {\n\t\t\tdefer{ shared.mut_mouse_state.unlock(); };\n\n\t\t\tfor (auto& x : event_queue_cache.click) {\n\t\t\t\tupdate_displays_from_click(*shared.mouse_state, x);\n\t\t\t\tshared.mouse_state->increment_button(transform_click_to_canonical(x));\n\t\t\t}\n\t\t\tevent_queue_cache.click.clear();\n\t\t\tevent_queue_cache.display.clear();\n\t\t}\n\n\t\tif (\n\t\t\tshared.keyboard_state &&\n\t\t\t!event_queue_cache.keyboard.empty() &&\n\t\t\tshared.mut_keyboard_state.try_lock()\n\t\t) {\n\t\t\tdefer{ shared.mut_keyboard_state.unlock(); };\n\t\t\t\t\n\t\t\tfor (auto x : event_queue_cache.keyboard) shared.keyboard_state->increment_key(x);\n\t\t\tevent_queue_cache.keyboard.clear();\n\t\t}\n\t\t\n\t\tif (\n\t\t\tshared.event_state &&\n\t\t\t!event_queue_cache.app_usages.empty() &&\n\t\t\tshared.mut_event_state.try_lock()\n\t\t) {\n\t\t\tdefer{ shared.mut_event_state.unlock(); };\n\n\t\t\tfor (auto& x : event_queue_cache.app_usages)\n\t\t\t\tshared.event_state->register_event(x);\n\n\t\t\tevent_queue_cache.app_usages.clear();\n\t\t}\n\t}\n}\n\nClickEntry transform_click_to_canonical(ClickEntry x) noexcept {\n\tauto screens = get_all_screens();\n\n\tx.x += screens.main_x;\n\tx.y += screens.main_y;\n\treturn x;\n}\n\nvoid update_displays_from_click(MouseState& state, ClickEntry x) noexcept {\n#undef max\n\tconstexpr auto MAX = std::numeric_limits<decltype(Display::timestamp_end)>::max();\n\n\tauto screen_is_display = [](Screen s, Display d) {\n\t\treturn\n\t\t\t(memcmp(s.unique_hash_char, d.unique_hash_char, Display::Unique_Hash_Size) == 0) &&\n\t\t\ts.x == d.x && s.y == d.y && s.width == d.width && s.height == d.height;\n\t};\n\n\tauto screens = get_all_screens();\n\n\tstd::unordered_set<Screen> screens_found;\n\tfor (auto& d : state.display_entries) {\n\t\t// We are intersted only in the displays that are alive.\n\t\tif (d.timestamp_end != MAX) continue;\n\n\t\tbool found = false;\n\t\tfor (auto& y : screens.screens) {\n\t\t\tif (screen_is_display(y, d)) {\n\t\t\t\tfound = true;\n\t\t\t\tscreens_found.insert(y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If we can't find the registered display d in the actual screen set 'screens'\n\t\t// Then that mean that d has been disconnected and we should terminate it\n\t\t// taking x.timestamp as it's death time.\n\t\tif (!found) {\n\t\t\td.timestamp_end = x.timestamp;\n\t\t}\n\t}\n\n\t// Now the screens in 'screens.screens' that are _not_ in (screens_found'\n\t// are screens that we see for the first time ever ! So we simply register them.\n\tfor (auto& s : screens.screens) {\n\t\tif (screens_found.count(s) > 0) continue;\n\n\t\tDisplay d;\n\t\td.x = s.x;\n\t\td.y = s.y;\n\t\tmemcpy_s(\n\t\t\t&d.unique_hash_char,\n\t\t\tDisplay::Unique_Hash_Size,\n\t\t\t&s.unique_hash_char,\n\t\t\tDisplay::Unique_Hash_Size\n\t\t);\n\t\tmemset(d.custom_name, 0, Display::Custom_Name_Size);\n\t\td.width = s.width;\n\t\td.height = s.height;\n\t\td.timestamp_start = x.timestamp;\n\t\td.timestamp_end = MAX;\n\n\t\tstate.display_entries.push_back(d);\n\t}\n}\n\n#define PROFILER_BEGIN_SEQ(x)\n#define PROFILER_END_SEQ()\n#define PROFILER_SEQ(x)\n\nstd::optional<HGLRC> create_gl_context(HWND handle_window) noexcept {\n\tPROFILER_BEGIN_SEQ(\"DC\");\n\tauto dc = GetDC(handle_window);\n\tif (!dc) {\n\t\t// >TODO error handling\n\t\tprintf(\"%s\", get_last_error_message()->c_str());\n\t\treturn std::nullopt;\n\t}\n\tdefer{ ReleaseDC(handle_window, dc); };\n\n\tPROFILER_SEQ(\"Pixel\");\n\tPIXELFORMATDESCRIPTOR pixel_format{};\n\tpixel_format.nSize = sizeof(PIXELFORMATDESCRIPTOR);\n\tpixel_format.nVersion = 1;\n\tpixel_format.dwFlags = PFD_SUPPORT_OPENGL | PFD_DRAW_TO_WINDOW | PFD_DOUBLEBUFFER;\n\tpixel_format.cColorBits = 32;\n\tpixel_format.cAlphaBits = 8;\n\tpixel_format.iLayerType = PFD_MAIN_PLANE;\n\n\tPROFILER_BEGIN_SEQ(\"choose\");\n\tauto suggested_pixel_format = ChoosePixelFormat(dc, &pixel_format);\n\tif (!suggested_pixel_format) {\n\t\t// >TODO error handling\n\t\tprintf(\"%s\", get_last_error_message()->c_str());\n\t\treturn std::nullopt;\n\t}\n\tPROFILER_SEQ(\"describe\");\n\tauto result = DescribePixelFormat(\n\t\tdc, suggested_pixel_format, sizeof(PIXELFORMATDESCRIPTOR), &pixel_format\n\t);\n\tif (!result) {\n\t\t// >TODO error handling\n\t\tprintf(\"%s\", get_last_error_message()->c_str());\n\t\treturn std::nullopt;\n\t}\n\n\tPROFILER_SEQ(\"set\");\n\tif (!SetPixelFormat(dc, suggested_pixel_format, &pixel_format)) {\n\t\t// >TODO error handling\n\t\tprintf(\"%s\", get_last_error_message()->c_str());\n\t\treturn std::nullopt;\n\t}\n\tPROFILER_END_SEQ();\n\n\tPROFILER_SEQ(\"first context\");\n\tauto gl_context = wglCreateContext(dc);\n\tif (!gl_context) {\n\t\t// >TODO error handling\n\t\tprintf(\"%s\", get_last_error_message()->c_str());\n\t\treturn std::nullopt;\n\t}\n\n\tif (!wglMakeCurrent(dc, gl_context)) {\n\t\twglDeleteContext(gl_context);\n\n\t\tprintf(\"%s\", get_last_error_message()->c_str());\n\t\treturn std::nullopt;\n\t}\n\n\tPROFILER_SEQ(\"glew\");\n\tglewExperimental = true; // Needed for core profile\n\tif (glewInit() != GLEW_OK) {\n\t\tprintf(\"Can't init glew\\n\");\n\t\treturn gl_context;\n\t}\n\n\tstatic int attribs[] = {\n\t#ifndef NDEBUG\n\t\tWGL_CONTEXT_FLAGS_ARB, WGL_CONTEXT_DEBUG_BIT_ARB,\n\t#endif\n\t\t0\n\t};\n\n\tPROFILER_SEQ(\"second context\");\n\tauto gl = wglCreateContextAttribsARB(dc, nullptr, attribs);\n\tif (!gl) {\n\t\tauto err = glGetError();\n\t\tprintf(\"%s\", std::to_string(err).c_str());\n\n\t\treturn gl_context;\n\t}\n\n\tif (!wglMakeCurrent(dc, gl)) {\n\t\twglDeleteContext(gl);\n\t\treturn gl_context;\n\t}\n\n\n\tPROFILER_SEQ(\"destroy\");\n\twglDeleteContext(gl_context);\n\tPROFILER_END_SEQ();\n\treturn (HGLRC)gl;\n}\nvoid destroy_gl_context(HGLRC gl_context) noexcept {\n\t// >TODO error handling\n\tif (!wglDeleteContext(gl_context)) {\n\t\tprintf(\"%s\", get_last_error_message()->c_str());\n\t}\n}\n\nstd::optional<std::string> get_last_error_message() noexcept {\n\tDWORD errorMessageID = ::GetLastError();\n\tif (errorMessageID == 0)\n\t\treturn std::nullopt; //No error message has been recorded\n\n\tLPSTR messageBuffer = nullptr;\n\tauto flags = FORMAT_MESSAGE_ALLOCATE_BUFFER;\n\tflags |= FORMAT_MESSAGE_FROM_SYSTEM;\n\tflags |= FORMAT_MESSAGE_IGNORE_INSERTS;\n\tsize_t size = FormatMessageA(\n\t\tflags, nullptr, errorMessageID, 0, (LPSTR)&messageBuffer, 0, nullptr\n\t);\n\n\tstd::string message(messageBuffer, size);\n\n\tLocalFree(messageBuffer);\n\treturn message;\n}\n\nvoid make_mail() noexcept {\n\tshared.mail_slot = CreateMailslot(Mail_Name, 0, MAILSLOT_WAIT_FOREVER, nullptr);\n\n\tif (shared.mail_slot == INVALID_HANDLE_VALUE) {\n\t\tfprintf(stderr, \"Error creating mail slot\\n\");\n\t}\n}\n\nstd::optional<Mail_Message> read_mail() noexcept {\n\tif (shared.mail_slot == INVALID_HANDLE_VALUE) return std::nullopt;\n\tDWORD cbMessage = 0;\n\tDWORD cMessage = 0;\n\tDWORD cbRead = 0; \n\tBOOL fResult; \n\tLPTSTR lpszBuffer; \n\tTCHAR achID[80]; \n\tDWORD cAllMessages; \n\tOVERLAPPED ov;\n\n\tHANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, TEXT(\"SP_Event\"));\n\tif (!hEvent) return std::nullopt;\n\n\tov.Offset = 0;\n\tov.OffsetHigh = 0;\n\tov.hEvent = hEvent;\n\n\tfResult = GetMailslotInfo(\n\t\tshared.mail_slot, // mailslot handle \n\t\tnullptr,\n\t    &cbMessage,                   // size of next message \n\t    &cMessage,                    // number of messages \n\t    nullptr\n\t);              // no read time-out \n\n\tif (!fResult) {\n\t    fprintf(stderr, \"GetMailslotInfo failed with %d.\\n\", GetLastError()); \n\t    return std::nullopt;\n\t}\n\n\tif (cbMessage == MAILSLOT_NO_MESSAGE) {\n\t    return std::nullopt;\n\t} \n\n\tcAllMessages = cMessage;\n\n\t// Allocate memory for the message.\n\n\tlpszBuffer = (LPTSTR)GlobalAlloc(GPTR, lstrlen((LPTSTR) achID) * sizeof(TCHAR) + cbMessage);\n\n\tif(!lpszBuffer) return std::nullopt;\n\n\tlpszBuffer[0] = '\\0'; \n\n\tfResult = ReadFile(shared.mail_slot, lpszBuffer, cbMessage, &cbRead, &ov);\n\n\tif (!fResult) {\n\t    fprintf(stderr, \"ReadFile failed with %d.\\n\", GetLastError());\n\t    GlobalFree((HGLOBAL) lpszBuffer);\n\t    return std::nullopt;\n\t}\n\n\t// Concatenate the message and the message-number string. \n\n\n\tGlobalFree((HGLOBAL) lpszBuffer); \n\n\tfResult = GetMailslotInfo(\n\t\tshared.mail_slot,              // mailslot handle \n\t    (LPDWORD) NULL,               // no maximum message size \n\t    &cbMessage,                   // size of next message \n\t    &cMessage,                    // number of messages \n\t    (LPDWORD) NULL                // no read time-out\n\t);\n\n\tif (!fResult) {\n\t    fprintf(stderr, \"GetMailslotInfo failed (%d)\\n\", GetLastError());\n\t    return std::nullopt;\n\t}\n\n\tCloseHandle(hEvent);\n\n\treturn *reinterpret_cast<Mail_Message*>(lpszBuffer);\n}",
			"file": "src/Main.cpp",
			"file_size": 34271,
			"file_write_time": 132432002406008484,
			"settings":
			{
				"buffer_size": 33083,
				"line_ending": "Windows"
			}
		},
		{
			"file": "src/Event.hpp",
			"settings":
			{
				"buffer_size": 1929,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "{\n\t\"shell_cmd\": \"make\"\n}\n",
			"settings":
			{
				"buffer_size": 25,
				"line_ending": "Windows",
				"name": "untitled.sublime-build"
			}
		},
		{
			"file": "/C/Users/Tackwin/AppData/Roaming/Sublime Text 3/Packages/User/cmake.sublime-build",
			"settings":
			{
				"buffer_size": 886,
				"line_ending": "Windows"
			}
		},
		{
			"file": "/C/Users/Tackwin/.gitignore",
			"settings":
			{
				"buffer_size": 17,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": ".gitignore",
			"settings":
			{
				"buffer_size": 111,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Logs.cpp",
			"settings":
			{
				"buffer_size": 2631,
				"line_ending": "Windows"
			}
		},
		{
			"file": "CMakeLists.txt",
			"settings":
			{
				"buffer_size": 2375,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"contents": "",
			"file": "src/imconfig.h",
			"file_size": 0,
			"file_write_time": 132413670476920707,
			"settings":
			{
				"buffer_size": 0,
				"line_ending": "Windows"
			}
		},
		{
			"file": "src/OS/win/FileInfo.cpp",
			"settings":
			{
				"buffer_size": 1719,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "src/Common.cpp",
			"settings":
			{
				"buffer_size": 3915,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "src/Common.hpp",
			"settings":
			{
				"buffer_size": 1708,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "src/Event.cpp",
			"settings":
			{
				"buffer_size": 8588,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "Searching 221 files for \"defer\"\n\nC:\\Users\\Tackwin\\Documents\\Code\\Mes_Touches\\src\\Common.hpp:\n    6  namespace details {\n    7  \ttemplate<typename Callable>\n    8: \tstruct Defer {\n    9: \t\t~Defer() noexcept { todo(); }\n   10: \t\tDefer(Callable todo) noexcept : todo(todo) {};\n   11  \tprivate:\n   12  \t\tCallable todo;\n   ..\n   14  };\n   15  \n   16: #define defer details::Defer _CONCAT(defer_, __COUNTER__) = [&]\n   17  #define BEG(x) std::begin(x)\n   18  #define BEG_END(x) std::begin(x), std::end(x)\n\nC:\\Users\\Tackwin\\Documents\\Code\\Mes_Touches\\src\\Event.cpp:\n  169  void EventWindow::render(std::optional<EventState>& state) noexcept {\n  170  \tImGui::Begin(\"Event\");\n  171: \tdefer { ImGui::End(); };\n  172  \n  173  \tif (reset_time_start == 0 && ImGui::Button(\"Reset\")) {\n  ...\n  240  \n  241  \t\tif (open) {\n  242: \t\t\tdefer { ImGui::TreePop(); };\n  243  \t\t\tfor (auto& doc : state->cache.exe_to_docs[name]) {\n  244  \t\t\t\tImGuiTreeNodeFlags flags =\n\nC:\\Users\\Tackwin\\Documents\\Code\\Mes_Touches\\src\\File_Win.cpp:\n   44  \t\treturn std::filesystem::current_path();\n   45  \t}\n   46: \tdefer{ CoTaskMemFree(buffer); };\n   47  \n   48  \tauto str = std::wstring{ buffer };\n   ..\n   68  \t\treturn std::nullopt;\n   69  \t}\n   70: \tdefer{ fclose(file); };\n   71  \n   72  \tfseek(file, 0, SEEK_END);\n   ..\n   89  \tauto err = fopen_s(&f, path.generic_string().c_str(), \"rb+\");\n   90  \tif (!f || err) return err;\n   91: \tdefer{ fclose(f); };\n   92  \n   93  \tauto wrote = fwrite(bytes.data(), 1, bytes.size(), f);\n   ..\n  107  \t\treturn err;\n  108  \t}\n  109: \tdefer{ fclose(f); };\n  110  \n  111  \tauto wrote = fwrite(bytes.data(), 1, bytes.size(), f);\n  ...\n  123  \t\treturn std::nullopt;\n  124  \t}\n  125: \tdefer{ fclose(f); };\n  126  \n  127  \tfseek(f, 0, SEEK_END);\n  ...\n  154  \tauto err = fopen_s(&f, path.generic_string().c_str(), \"rb+\");\n  155  \tif (!f || err) return err;\n  156: \tdefer{ fclose(f); };\n  157  \n  158  \tfseek(f, offset, SEEK_CUR);\n  ...\n  183  \tauto err = fopen_s(&f, path.generic_string().c_str(), \"rb+\");\n  184  \tif (!f || err) return err;\n  185: \tdefer{ fclose(f); };\n  186  \n  187  \tfseek(f, 0, SEEK_END);\n  ...\n  226  \tauto err = fopen_s(&f, path.generic_string().c_str(), \"rb+\");\n  227  \tif (!f || err) return err;\n  228: \tdefer{ fclose(f); };\n  229  \n  230  \tfseek(f, 0, SEEK_END);\n  ...\n  248  \t\treturn std::nullopt;\n  249  \t}\n  250: \tdefer{ fclose(f); };\n  251  \n  252  \terr = fseek(f, 0, SEEK_END);\n\nC:\\Users\\Tackwin\\Documents\\Code\\Mes_Touches\\src\\keyboard.cpp:\n  172  \n  173  \tImGui::Begin(\"Keyboard\");\n  174: \tdefer{ ImGui::End(); };\n  175  \tif (reset_time_start == 0 && ImGui::Button(\"Reset\")) {\n  176  \t\treset_time_start = time(nullptr);\n\nC:\\Users\\Tackwin\\Documents\\Code\\Mes_Touches\\src\\Logs.cpp:\n   33  \n   34  \tImGui::Begin(\"Log\", &open);\n   35: \tdefer{ ImGui::End(); };\n   36  \n   37  \tauto window_width = ImGui::GetWindowContentRegionWidth();\n   ..\n   42  \tfor (size_t i = l.entries.size() - 1; i + 1 > 0; --i) {\n   43  \t\tImGui::PushID(i);\n   44: \t\tdefer{ ImGui::PopID(); };\n   45  \n   46  \t\tauto& x = l.entries[i];\n   ..\n   76  \tfor (size_t i = l.errors.size() - 1; i + 1 > 0; --i) {\n   77  \t\tImGui::PushID(i);\n   78: \t\tdefer{ ImGui::PopID(); };\n   79  \n   80  \t\tauto& x = l.errors[i];\n   ..\n  107  \t\tif (ImGui::BeginPopup(\"Complete\")) {\n  108  \t\t\tImGui::PushItemWidth(200);\n  109: \t\t\tdefer{\n  110  \t\t\t\tImGui::PopItemWidth();\n  111  \t\t\t\tImGui::EndPopup();\n\nC:\\Users\\Tackwin\\Documents\\Code\\Mes_Touches\\src\\Main.cpp:\n  249  \t\tEventState::load_from_file(get_app_data_path() / EventState::Default_Path);\n  250  \n  251: \tdefer{\n  252  \t\tif (shared.keyboard_state) {\n  253  \t\t\t(void)shared.keyboard_state->save_to_file(get_app_data_path() / Default_Keyboard_Path);\n  ...\n  283  \n  284  \tRegisterClassEx(&wc);\n  285: \tdefer{ UnregisterClass(hook_class_name, wc.hInstance); };\n  286  \tHWND hwnd = CreateWindow(\n  287  \t\thook_class_name,\n  ...\n  304  \tstd::thread{ event_queue_process }.detach();\n  305  \n  306: \tdefer{ DestroyWindow(hwnd); };\n  307: \tdefer{ shared.hook_window = nullptr; };\n  308  \n  309  #if REGISTER_HOOKS\n  ...\n  321  \tmake_mail();\n  322  \tinstall_hook();\n  323: \tdefer { uninstall_hook(); };\n  324  #endif\n  325  #endif\n  ...\n  332  \tsys_tray_icon.add();\n  333  \tsys_tray_icon.show();\n  334: \tdefer{ sys_tray_icon.remove(); };\n  335  \n  336  \tLogEntry entry;\n  ...\n  393  \tshared.visu_window = hwnd;\n  394  \n  395: \tdefer{\n  396  \t\tUnregisterClass(visu_class_name, wc.hInstance);\n  397  \t\tDestroyWindow(hwnd);\n  ...\n  401  \n  402  \tauto gl_context = *create_gl_context(hwnd);\n  403: \tdefer{ destroy_gl_context(gl_context); };\n  404  \n  405  \t// Setup Dear ImGui context\n  ...\n  437  \t}\n  438  \t\n  439: \tdefer{\n  440  \t\tImGui_ImplOpenGL3_Shutdown();\n  441  \t\tImGui_ImplWin32_Shutdown();\n  ...\n  508  \n  509  \t\tif (ImGui::BeginPopup(\"Error Prompt\")) {\n  510: \t\t\tdefer{ ImGui::EndPopup(); };\n  511  \n  512  \t\t\tImGui::Text(\"The last action ended with an error see the logs for more details.\");\n  ...\n  631  \n  632  \tauto time_start = get_microseconds_epoch();\n  633: \tdefer{\n  634  \t\tauto time_end = get_microseconds_epoch();\n  635  \t\tauto dt = time_end - time_start;\n  ...\n  662  \n  663  \tif (!key_entries_to_add.empty() && event_queue_cache.mutex.try_lock()) {\n  664: \t\tdefer{\n  665  \t\t\tevent_queue_cache.mutex.unlock();\n  666  \t\t\tevent_queue_cache.wait_var.notify_all();\n  ...\n  678  \n  679  \tauto time_start = get_microseconds_epoch();\n  680: \tdefer{\n  681  \t\tauto time_end = get_microseconds_epoch();\n  682  \t\tauto dt = time_end - time_start;\n  ...\n  741  \n  742  \tif (!click_entries_to_add.empty() && event_queue_cache.mutex.try_lock()) {\n  743: \t\tdefer{\n  744  \t\t\tevent_queue_cache.mutex.unlock();\n  745  \t\t\tevent_queue_cache.wait_var.notify_all();\n  ...\n  823  \n  824  \tif (!entries_to_add.empty() && event_queue_cache.mutex.try_lock()) {\n  825: \t\tdefer {\n  826  \t\t\tentries_to_add.clear();\n  827  \t\t\tevent_queue_cache.mutex.unlock();\n  ...\n  857  \t\t\tshared.mut_mouse_state.try_lock()\n  858  \t\t) {\n  859: \t\t\tdefer{ shared.mut_mouse_state.unlock(); };\n  860  \n  861  \t\t\tfor (auto& x : event_queue_cache.click) {\n  ...\n  872  \t\t\tshared.mut_keyboard_state.try_lock()\n  873  \t\t) {\n  874: \t\t\tdefer{ shared.mut_keyboard_state.unlock(); };\n  875  \t\t\t\t\n  876  \t\t\tfor (auto x : event_queue_cache.keyboard) shared.keyboard_state->increment_key(x);\n  ...\n  883  \t\t\tshared.mut_event_state.try_lock()\n  884  \t\t) {\n  885: \t\t\tdefer{ shared.mut_event_state.unlock(); };\n  886  \n  887  \t\t\tfor (auto& x : event_queue_cache.app_usages)\n  ...\n  971  \t\treturn std::nullopt;\n  972  \t}\n  973: \tdefer{ ReleaseDC(handle_window, dc); };\n  974  \n  975  \tPROFILER_SEQ(\"Pixel\");\n\nC:\\Users\\Tackwin\\Documents\\Code\\Mes_Touches\\src\\Mouse.cpp:\n  131  \n  132  \tImGui::Begin(\"Mouse\");\n  133: \tdefer{ ImGui::End(); };\n  134  \n  135  \tif (reset_time_start == 0 && ImGui::Button(\"Reset\")) {\n  ...\n  179  \t\t\tif (*x.custom_name) name = x.custom_name;\n  180  \t\t\tImGui::PushID(i);\n  181: \t\t\tdefer { ImGui::PopID(); };\n  182  \n  183  \t\t\tif (display_list_focused && display_list_selected == i) {\n\nC:\\Users\\Tackwin\\Documents\\Code\\Mes_Touches\\src\\render_stats.cpp:\n  250  \tImPlot::SetNextPlotLimitsX(0, ms.cache.usage_plot.resolution);\n  251  \tif (!ImPlot::BeginPlot(\"Mouse usage\", \"Time\", \"Usage\")) return;\n  252: \tdefer { ImPlot::EndPlot(); };\n  253  \n  254  \tif (ms.cache.usage_plot.dirty && !ms.click_entries.empty()) {\n\nC:\\Users\\Tackwin\\Documents\\Code\\Mes_Touches\\src\\Settings.cpp:\n   92  \t\t\treturn false;\n   93  \t\t}\n   94: \t\tdefer{ RegCloseKey(hkey); };\n   95  \n   96  \t\tresult = RegSetValueExW(\n   ..\n  130  \t\t}\n  131  \n  132: \t\tdefer { RegCloseKey(hkey); };\n  133  \n  134  \t\tresult = RegDeleteValueW(hkey, Reg_Value);\n  ...\n  151  \n  152  \tImGui::Begin(\"System\");\n  153: \tdefer{ ImGui::End(); };\n  154  \n  155  \tif (ImGui::Checkbox(\"Start on startup\", &settings.start_on_startup)) {\n\nC:\\Users\\Tackwin\\Documents\\Code\\Mes_Touches\\src\\imgui\\imgui.cpp:\n 2583          need_clipping |= (pos.x < clip_min->x) || (pos.y < clip_min->y);\n 2584  \n 2585:     // Align whole block. We should defer that to the better rendering function when we'll have support for individual line alignment.\n 2586      if (align.x > 0.0f) pos.x = ImMax(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x);\n 2587      if (align.y > 0.0f) pos.y = ImMax(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y);\n ....\n 5726      if (has_collapse_button)\n 5727          if (CollapseButton(window->GetID(\"#COLLAPSE\"), collapse_button_pos, NULL))\n 5728:             window->WantCollapseToggle = true; // Defer actual collapsing to next frame as we are too far in the Begin() function\n 5729  \n 5730      // Close button\n ....\n 11065              // Scale our window moving pivot so that the window will rescale roughly around the mouse position.\n 11066              // FIXME-VIEWPORT: This currently creates a resizing feedback loop when a window is straddling a DPI transition border.\n 11067:             // (Minor: since our sizes do not perfectly linearly scale, deferring the click offset scale until we know the actual window scale ratio may get us slightly more precise mouse positioning.)\n 11068              //if (g.MovingWindow != NULL && g.MovingWindow->Viewport == viewport)\n 11069              //    g.ActiveIdClickOffset = ImFloor(g.ActiveIdClickOffset * scale_factor);\n .....\n 12800      }\n 12801  \n 12802:     // In some circumstance we will defer creating the host window (so everything will be kept hidden),\n 12803      // while the expected visible window is resizing itself.\n 12804      // This is important for first-time (no ini settings restored) single window when io.ConfigDockingAlwaysTabBar is enabled,\n\nC:\\Users\\Tackwin\\Documents\\Code\\Mes_Touches\\src\\imgui\\imgui.h:\n  847      ImGuiWindowFlags_NoNavInputs = 1 << 18,  // No gamepad/keyboard navigation within the window\n  848      ImGuiWindowFlags_NoNavFocus = 1 << 19,  // No focusing toward this window with gamepad/keyboard navigation (e.g. skipped by CTRL+TAB)\n  849:     ImGuiWindowFlags_UnsavedDocument = 1 << 20,  // Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. When used in a tab/docking context, tab is selected on closure and closure is deferred by one frame to allow code to cancel the closure (with a confirmation popup, etc.) without flicker.\n  850      ImGuiWindowFlags_NoDocking = 1 << 21,  // Disable docking of this window\n  851  \n  ...\n  983  {\n  984      ImGuiTabItemFlags_None = 0,\n  985:     ImGuiTabItemFlags_UnsavedDocument = 1 << 0,   // Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. Also: tab is selected on closure and closure is deferred by one frame to allow code to undo it without flicker.\n  986      ImGuiTabItemFlags_SetSelected = 1 << 1,   // Trigger flag to programmatically make the tab selected when calling BeginTabItem()\n  987      ImGuiTabItemFlags_NoCloseWithMiddleMouseButton = 1 << 2,   // Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.\n\n53 matches across 11 files\n",
			"settings":
			{
				"buffer_size": 11115,
				"line_ending": "Windows",
				"name": "Find Results",
				"scratch": true
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
		[
			[
				[
					"Packages/User/cmake.sublime-build",
					""
				],
				[
					"Packages/User/cmake.sublime-build",
					"Release"
				],
				[
					"Packages/User/cmake.sublime-build",
					"Debug"
				],
				[
					"Packages/User/cmake.sublime-build",
					"Clear"
				],
				[
					"Packages/User/cmake.sublime-build",
					"Run"
				]
			],
			[
				"Packages/User/cmake.sublime-build",
				""
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"rel",
				"Build With: cmake - Release"
			],
			[
				"rele",
				"Build With: cmake - Release"
			],
			[
				"run",
				"Build With: cmake - Run"
			],
			[
				"re",
				"Build With: cmake - Release"
			],
			[
				"termin",
				"Terminus: Open Default Shell in Tab (View)"
			],
			[
				"nim",
				"Nimpretty: Format this file"
			],
			[
				"packa",
				"Package Control: Install Package"
			],
			[
				"pac",
				"Package Control: Add Channel"
			],
			[
				"debug",
				"Build With: cmake - Debug"
			],
			[
				"r",
				"Build With: cmake - Run"
			],
			[
				"keybi",
				"Preferences: Key Bindings"
			],
			[
				"ru",
				"Build With: cmake - Run"
			],
			[
				"ter",
				"Terminus: Open Default Shell in Tab (View)"
			],
			[
				"termi",
				"Terminus: Open Default Shell in Tab (View)"
			],
			[
				"- ck",
				"Build With: cmake - Clear"
			],
			[
				"debu",
				"Build With: cmake - Debug"
			],
			[
				"prefer",
				"Preferences: Settings"
			],
			[
				"wor",
				"Word Wrap: Toggle"
			],
			[
				"term",
				"Terminus: Open Default Shell in Tab (View)"
			],
			[
				"deb",
				"Build With: cmake - Debug"
			],
			[
				"TERMUN",
				"Terminus: Open Default Shell in Tab (View)"
			],
			[
				"TERM",
				"Terminus: Close"
			],
			[
				"- ",
				"Build With: cmake - Clear"
			],
			[
				"cmak",
				"Build With: cmake - Clear"
			],
			[
				"clea",
				"Bookmarks: Clear All"
			],
			[
				"buil",
				"Build: New Build System"
			],
			[
				"cma",
				"Build With: cmake - Release"
			],
			[
				"set s",
				"Set Syntax: C++"
			],
			[
				"keyb",
				"Preferences: Key Bindings"
			],
			[
				"s",
				"Set Syntax: C++"
			],
			[
				"side",
				"View: Toggle Side Bar"
			],
			[
				"key",
				"Preferences: Key Bindings"
			],
			[
				"terminus",
				"Preferences: Terminus Settings"
			],
			[
				"te",
				"Terminus: Toggle Panel"
			],
			[
				"ins",
				"Package Control: Install Package"
			],
			[
				"rem",
				"Package Control: Remove Package"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"remove",
				"Package Control: Remove Package"
			],
			[
				"shelle",
				"Sheller: Open shell window at Project Root"
			],
			[
				"insta",
				"Package Control: Install Package"
			],
			[
				"new",
				"Build: New Build System"
			],
			[
				"instal",
				"Package Control: Install Package"
			],
			[
				"reler",
				"Set Syntax: Regular Expression"
			],
			[
				"build",
				"Build With: cmake - Release"
			],
			[
				"b",
				"Build With: cmake - Release"
			]
		],
		"width": 0.0
	},
	"console":
	{
		"height": 157.0,
		"history":
		[
			"x",
			"x = 1",
			"os(\"zig\")",
			"exit()",
			"exit",
			"zig"
		]
	},
	"distraction_free":
	{
		"menu_visible": false,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/C/Users/Tackwin/Documents/Code/Mes_Touches",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/src",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/src/OS"
	],
	"file_history":
	[
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/win_hook.lib",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/CMakeLists.txt",
		"/C/Users/Tackwin/AppData/Roaming/Sublime Text 3/Packages/User/cmake.sublime-build",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/src/cbt_hook.cpp",
		"/C/Users/Tackwin/Documents/Code/sans-peine/Client/src/Main.cpp",
		"/C/Users/Tackwin/Documents/Code/sans-peine/Simulation/src/Main.cpp",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/src/Event.cpp",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/src/Event.hpp",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/eject.ps1",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/src/Settings.cpp",
		"/C/Users/Tackwin/Documents/Code/sans-peine/Client/src/imgui_ext.h",
		"/C/Users/Tackwin/Documents/Code/sans-peine/Client/src/imgui_ext.cpp",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/dbg.h",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/Main.cpp",
		"/C/Users/Tackwin/Documents/Code/sans-peine/Simulation/CMakeLists.txt",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/src/NotifyIcon.hpp",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/src/imgui/imgui_ext.h",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/src/imgui/imgui_ext.cpp",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/src/Main.cpp",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/src/Mouse.cpp",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/src/keyboard.cpp",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/src/render_stats.hpp",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/src/render_stats.cpp",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/win_hook.exp",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/src/TimeInfo.hpp",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/src/Mes_Touches.rc",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/src/cbt_hook.hpp",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/src/Logs.hpp",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/src/NotifyIcon.cpp",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/src/xstd.hpp",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/src/imgui/imgui.h",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/src/Mouse.hpp",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/src/keyboard.hpp",
		"/C/Users/Tackwin/Documents/Code/Mes_Touches/src/resource.h",
		"/C/Users/Tackwin/Documents/Soft/nim-1.2.6/examples/talk/dsl.nim",
		"/N/Formatage dcembre 2018/Crypto/Ethereum/private key",
		"/N/Formatage dcembre 2018/Crypto/Ethereum/MetaMask Seed Words",
		"/C/Users/Tackwin/Documents/Code/Calme/Cargo.toml",
		"/C/Users/Tackwin/Documents/Code/Calme/src/main.rs",
		"/C/Users/Tackwin/Documents/Code/Calme/.cargo/config.toml",
		"/C/Users/Tackwin/Documents/Code/Calme/src/vga_buffer.rs",
		"/C/Users/Tackwin/Documents/Code/Calme/src/x86_64-calme.json",
		"/C/Users/Tackwin/Documents/Code/Calme/Calme.sublime-project",
		"/C/Users/Tackwin/AppData/Roaming/Sublime Text 3/Packages/Default/Default (Windows).sublime-keymap"
	],
	"find":
	{
		"height": 28.0
	},
	"find_in_files":
	{
		"height": 107.0,
		"where_history":
		[
			"",
			"(?!imgui)",
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"Window",
			"defer",
			"ImPlotLimits",
			"defer",
			"dirty",
			"di",
			"cache",
			"install",
			"event_hook",
			"current",
			"printf",
			"event_hook",
			"Mail_Arrived_Msg",
			"Mail_Ar",
			"Mail_Me",
			"get_last_er",
			"destroy_gl_context",
			"main",
			"event_hook(",
			"event_hook",
			"OpenedApp",
			"event_hoo",
			"WM_NOTIFY_MSG",
			"set_tooltip",
			"is software and associated documentation files (the \"Software\"), to\n  deal "
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"AppUsage"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 5,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "src/NotifyIcon.hpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 567,
						"regions":
						{
						},
						"selection":
						[
							[
								115,
								115
							]
						],
						"settings":
						{
							"history_list_is_closing": true,
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 18,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "src/OS/FileInfo.hpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 175,
						"regions":
						{
						},
						"selection":
						[
							[
								70,
								70
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 16,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "src/Main.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 33083,
						"regions":
						{
						},
						"selection":
						[
							[
								1,
								1
							]
						],
						"settings":
						{
							"syntax": "Packages/Deviot (Arduino IDE)/deviot.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "src/Event.hpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1929,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 114.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 4,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 25,
						"regions":
						{
						},
						"selection":
						[
							[
								25,
								25
							]
						],
						"settings":
						{
							"default_dir": "C:\\Users\\Tackwin\\AppData\\Roaming\\Sublime Text 3\\Packages\\User",
							"syntax": "Packages/JavaScript/JSON.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "/C/Users/Tackwin/AppData/Roaming/Sublime Text 3/Packages/User/cmake.sublime-build",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 886,
						"regions":
						{
						},
						"selection":
						[
							[
								176,
								246
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JSON.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "/C/Users/Tackwin/.gitignore",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 17,
						"regions":
						{
						},
						"selection":
						[
							[
								17,
								17
							]
						],
						"settings":
						{
							"syntax": "Packages/Git Formats/Git Ignore.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 12,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": ".gitignore",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 111,
						"regions":
						{
						},
						"selection":
						[
							[
								111,
								111
							]
						],
						"settings":
						{
							"syntax": "Packages/Git Formats/Git Ignore.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "src/Logs.cpp",
					"semi_transient": true,
					"settings":
					{
						"buffer_size": 2631,
						"regions":
						{
						},
						"selection":
						[
							[
								287,
								287
							]
						],
						"settings":
						{
							"syntax": "Packages/Deviot (Arduino IDE)/deviot.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2375,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 774.0,
						"zoom_level": 1.0
					},
					"stack_index": 14,
					"type": "text"
				}
			]
		},
		{
			"selected": 7,
			"sheets":
			[
				{
					"buffer": 10,
					"file": "src/imconfig.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 0,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Deviot (Arduino IDE)/deviot.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 17,
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "src/OS/win/FileInfo.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1719,
						"regions":
						{
						},
						"selection":
						[
							[
								1133,
								1133
							]
						],
						"settings":
						{
							"syntax": "Packages/Deviot (Arduino IDE)/deviot.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 13,
					"type": "text"
				},
				{
					"buffer": 12,
					"file": "src/Common.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3915,
						"regions":
						{
						},
						"selection":
						[
							[
								3914,
								3914
							]
						],
						"settings":
						{
							"syntax": "Packages/Deviot (Arduino IDE)/deviot.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 1561.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 13,
					"file": "src/Common.hpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1708,
						"regions":
						{
						},
						"selection":
						[
							[
								1495,
								1495
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 441.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2375,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 448.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "src/Event.hpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1929,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 401.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 14,
					"file": "src/Event.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8588,
						"regions":
						{
						},
						"selection":
						[
							[
								6809,
								6809
							]
						],
						"settings":
						{
							"syntax": "Packages/Deviot (Arduino IDE)/deviot.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 4213.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "src/Main.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 33083,
						"regions":
						{
						},
						"selection":
						[
							[
								23257,
								23257
							]
						],
						"settings":
						{
							"syntax": "Packages/Deviot (Arduino IDE)/deviot.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 14877.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 15,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11115,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										171,
										176
									],
									[
										189,
										194
									],
									[
										227,
										232
									],
									[
										354,
										359
									],
									[
										369,
										374
									],
									[
										383,
										388
									],
									[
										675,
										680
									],
									[
										816,
										821
									],
									[
										1074,
										1079
									],
									[
										1212,
										1217
									],
									[
										1397,
										1402
									],
									[
										1534,
										1539
									],
									[
										1680,
										1685
									],
									[
										1859,
										1864
									],
									[
										2043,
										2048
									],
									[
										2222,
										2227
									],
									[
										2336,
										2341
									],
									[
										2515,
										2520
									],
									[
										2756,
										2761
									],
									[
										2960,
										2965
									],
									[
										3132,
										3137
									],
									[
										3297,
										3302
									],
									[
										3528,
										3533
									],
									[
										3723,
										3728
									],
									[
										3916,
										3921
									],
									[
										3955,
										3960
									],
									[
										4088,
										4093
									],
									[
										4218,
										4223
									],
									[
										4341,
										4346
									],
									[
										4509,
										4514
									],
									[
										4628,
										4633
									],
									[
										4785,
										4790
									],
									[
										4989,
										4994
									],
									[
										5193,
										5198
									],
									[
										5369,
										5374
									],
									[
										5575,
										5580
									],
									[
										5777,
										5782
									],
									[
										5936,
										5941
									],
									[
										6115,
										6120
									],
									[
										6339,
										6344
									],
									[
										6499,
										6504
									],
									[
										6685,
										6690
									],
									[
										6876,
										6881
									],
									[
										7197,
										7202
									],
									[
										7412,
										7417
									],
									[
										7517,
										7522
									],
									[
										7661,
										7666
									],
									[
										7969,
										7974
									],
									[
										8469,
										8474
									],
									[
										8930,
										8935
									],
									[
										9321,
										9326
									],
									[
										10139,
										10144
									],
									[
										10598,
										10603
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"detect_indentation": false,
							"line_numbers": false,
							"output_tag": 1,
							"result_base_dir": "",
							"result_file_regex": "^([^ \t].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 15,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 28.0
	},
	"input":
	{
		"height": 39.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			],
			[
				1,
				0,
				2,
				1
			]
		],
		"cols":
		[
			0.0,
			0.5,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.Terminus":
	{
		"height": 126.0
	},
	"output.exec":
	{
		"height": 367.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "Packages/User/cmake.sublime-build",
	"project": "Mes_Touches.sublime-project",
	"replace":
	{
		"height": 52.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"main",
				"src\\Main.cpp"
			],
			[
				"event",
				"src\\Event.hpp"
			],
			[
				"even",
				"src\\Event.hpp"
			],
			[
				"cmake",
				"CMakeLists.txt"
			],
			[
				"Com",
				"src\\Common.cpp"
			],
			[
				"ma",
				"src\\Main.cpp"
			],
			[
				"mai",
				"src\\Main.cpp"
			],
			[
				"cm",
				"CMakeLists.txt"
			],
			[
				"file",
				"src\\OS\\win\\FileInfo.cpp"
			],
			[
				"File",
				"src\\OS\\FileInfo.hpp"
			],
			[
				"render",
				"src\\render_stats.cpp"
			],
			[
				"im",
				"src\\imgui\\imgui_ext.h"
			],
			[
				"cmal",
				"CMakeLists.txt"
			],
			[
				"mouse",
				"src\\Mouse.cpp"
			],
			[
				"imgui_e",
				"src\\imgui\\imgui_ext.h"
			],
			[
				"imgui.h",
				"src\\imgui\\imgui.h"
			],
			[
				"sta",
				"src\\render_stats.cpp"
			],
			[
				"mo",
				"src\\Mouse.cpp"
			],
			[
				"set",
				"src\\Settings.cpp"
			],
			[
				"xstd",
				"src\\xstd.hpp"
			],
			[
				"e",
				"src\\Event.cpp"
			],
			[
				"cbt_",
				"src\\cbt_hook.cpp"
			],
			[
				"cbt",
				"src\\cbt_hook.cpp"
			],
			[
				"MAIN",
				"src\\Main.cpp"
			],
			[
				"cb",
				"src\\cbt_hook.cpp"
			],
			[
				"cma",
				"CMakeLists.txt"
			],
			[
				"eve",
				"src\\Event.cpp"
			],
			[
				"time",
				"src\\TimeInfo.hpp"
			],
			[
				"keyb",
				"src\\keyboard.cpp"
			],
			[
				"Mes_Touches.rc",
				"src\\Mes_Touches.rc"
			],
			[
				"noti",
				"src\\NotifyIcon.cpp"
			],
			[
				".rc",
				"src\\Mes_Touches.rc"
			],
			[
				"not",
				"src\\NotifyIcon.hpp"
			],
			[
				"",
				"src\\vga_buffer.rs"
			],
			[
				"vga",
				"src\\vga_buffer.rs"
			],
			[
				"conf",
				".cargo\\config.toml"
			],
			[
				"confi",
				".cargo\\config.toml"
			],
			[
				"cargo",
				"Cargo.toml"
			],
			[
				"carg",
				"Cargo.toml"
			],
			[
				"car",
				"Cargo.toml"
			],
			[
				"m",
				"src\\Main.cpp"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"",
				"C:\\Users\\Tackwin\\Documents\\Code\\sans-peine\\Client\\Client.sublime-project"
			]
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 1,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 245.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
